cc中间代码Pcode,在编译器中中间表示有着至关重要的作用，在经典的编译器LLVM中LLVM的中间IR是学习的重点。

这里介绍tinyc编译器的中间表示Pcode，Pcode虚拟机的内部结构，并且如何使用Pcode模拟器运行Pcode以及Pcode与tinyc程序之间的关系。

tinyc的中间代码Pcode，是基于pascal编译器的中间代码pcode，并结合逆波兰表达式也就是后缀表达式基于栈和符号表的虚拟代码，这样的设计会使编译器的设计大大简化。

Pcode的虚拟机其实就是一个运行Pcode代码的机器，它包括一个代码区、一个指令指针、一个栈、一个变量表、一个函数表、以及一个标签表。这个虚拟机选择使用python来编写。Pcode的命令都是在栈顶对附近的元素进行操作，例如经典的push/pop命令，add就是对栈顶的两个元素进行操作，然后再放回栈顶。

一个典型的表达式：

```c
x = 1 + 2 * 3;
```

在Pcode的表达中就为：

```
push 1
push 2
push 3
mul
add
pop x
```

其实这与后缀表达式基本一致

```
1 2 3 * +
```

Pcode 中以分号 ”;” 开始的为注释，以标识符加冒号的为标签（如 “Label:” ）

Pcode 命令一共只有7组，都是非常简单的命令，其中也可以分为**系统命令**和**自定义命令**两种，自定义命令其实就是函数调用，是对系统命令的扩充。以下详细介绍 Pcode 的系统命令、各命令执行过程中 Pcode 虚拟机的状态变化、如何创建自定义命令（函数）、以及如何用 Pcode 模拟器运行 Pcode 。

## 变量声明命令

var命令，声明变量，其本质就是向下增长栈的空间并把新增长的变量空间绑定给声明的变量，同时将变量名分配给它的地址保存到变量表中去。

```
var a           ; 栈顶向下增长 1 个单元，将新的栈顶单元分配（绑定）给 a
var x, y, z     ; 栈顶向下增长 3 个单元，将新的栈顶单元分配（绑定）给 x, y, z
```

var 命令运行后， Pcode 虚拟机会将刚刚声明的变量及分配给它的地址记录在变量表中，在后面的命令中可以根据变量名称来引用其内容。

在这里，栈的增长方向都是向下，这是为了和大部分计算机系统架构和编译原理教材的惯例保持一致。

## 入栈及出栈命令

push/pop命令

```
push 2   ; 将常数 2 入栈
push a   ; 将变量 a 的值入栈， a 必须已被声明、且已被赋值过
pop      ; 将栈顶向上减少一个单位
pop a    ; 取出栈顶元素，并赋给变量 a ， a 必须已被声明
```

当虚拟机执行 push 命令时，若后面是一个变量名，则虚拟机会在其变量表中查找此变量名，如果查到了，且该变量的值不是空值 “/” ，则将此变量名对应的值放入栈顶，但若此时该变量尚未被赋初值（为空值 “/” ），则虚拟机将出错而终止，如果没有查找到，则虚拟机也会出错终止。

“pop a” 命令运行后，栈顶的元素被取出，并将其值赋给了变量 a ，相当于 `a = stack.pop()` ，此命令是唯一一个能给 **直接** 给变量赋值的命令。栈的变化如下：

当虚拟机执行 pop 命令后，若后面是一个变量名，虚拟机会在其变量表中查找此变量名，若查到了，则虚拟机会将栈顶元素取出，赋给该变量名对应的栈单元，若没查到，虚拟机会出错终止。

此处同样需要注意的是，若此时 **栈顶单元** 尚未被赋初值（为空值 “/” ），则虚拟机将出错而终止。总而言之，栈上未被赋初值的单元是不能被使用（读取）的，此约束对后面将要介绍的所有命令都有效，因此后面就不再重复申明此约束了。

## 数据运算命令

**add / sub / mul / div / mod / cmpeq / cmpne / cmpgt / cmplt / cmpge / cmple / and / or / not / neg** 命令，包括算术、比较和逻辑运算命令。对应于 TinyC 中的以下运算符：

```
+, -, *, /, %, ==, !=, >, <, >=, <=, &&, ||, !, -
```

注意最后一个 “ - ” 是反号的意思，应和减号区别开来。

以上命令中，除 not 和 neg 命令外，其余命令均为二元操作命令，先取出栈顶两个元素，进行运算后，再将结果放回栈顶， not 和 neg 命令则为一元操作命令，只对栈顶一个元素进行操作。所有二元操作中， **原栈顶元素是第二个操作符** 。

## 输入及输出命令

**print / readint** 命令，用法如下：

```c
print "Hello world"         ; 输出：Hello world

push 1
push 2                      ; 相当于 print("(%d, %d)", 1, 2);
print "(%d, %d)"            ; 输出：(1, 2)

readint "Input: "
pop x                       ; 相当于 x = readint("Input: ");
```

print 命令会根据字符串的 “ %d ” 依次将栈顶元素取出，并打印出来，也就是说，上面第二个例子中 print 命令之前入栈的两个参数 1 和 2 ，在 print 后都将出栈。另外注意：参数的入栈的顺序需要从左向右入栈。

readint 命令先打印提示信息，再从标准输入中读取一个整数，返回后将其放入栈顶。

## 退出命令

**exit** 命令，退出虚拟机的运行，并设置退出码，有以下用法：

```
exit 0      ; 退出码为 0
exit a      ; 退出码为 a 的值
exit ~      ; 退出码为栈顶元素的值
```

上面的代码中用 “ ~ ” 来代表栈顶，这将是 Pcode 中的一个约定。

## 跳转命令

**jmp / jz** 命令。jmp 命令为无条件跳转命令，直接跳转到标签处，用法如下：

```
jmp Label
    ...
    ...
Label:
    print "jump here"
```

jz 命令为条件跳转命令，先取出栈顶元素，判断其是否为 0 ，若为 0 ，则跳转至标签处，若不为 0 ，则转到下一条命令，用法如下：

```
push 0
    jz Label
    print "top is not zero"
Label:
    print "top is zero"
```

Pcode 虚拟机会将所有以 “ xxx: ” 开始的行记录在其标签表中，在 jmp / jz 命令运行时，虚拟机会根据命令后的标签名在标签表中查找对应的地址，如果查不到标签名，虚拟机会出错终止。

## 自定义函数命令

**FUNC / ENDFUNC / arg / ret / $func_name** 命令。这组命令用来定义函数，这是 Pcode 的最后一组命令，也是最为复杂的一组命令，还是用个简单的例子来说明这组命令吧。

C 语言：

```c
...
sum(1, 2);
...

void sum(int a, int b) {
    return a + b;
}
```

对应的Pcode：

```c
push 1
push 2
$sum

FUNC @sum:
    arg a, b

    push a
    push b
    add
    ret ~
ENDFUNC
```

现在来对照着 C 语言中的函数定义和调用来说明这组命令。

FUNC 和 ENDFUNC 分别为函数开始和结尾，FUNC 后的函数名以 @ 开始，这是为了不与系统命令冲突，因为在 C 语言中有可能会定义一个名为 add 或 push 等和系统命令同名的函数。函数名后接一个冒号。

函数体内开始的第一个命令为 arg ，这是声明函数参数的，注意此命令不能和 FUNC 行写在同一行。如果函数没有参数，则此命令可以去掉。声明了函数参数，函数内部就可以根据参数名来引用函数调用者传递进来的参数了。

函数调用的时候，在函数名前加 “$” 就可以了，函数的参数通过栈传递，先 **从左向右** 将参数压入栈中（再次强调，是 **从左向右** ，也是为了更接近于源文件的阅读顺序），再调用函数。

Pcode 虚拟机会将所有用 FUNC 和 ENDFUNC 定义的函数名、函数入口地址及函数参数等相关信息记录在其函数表（func_table）中，当遇到以 $ 开头的命令时，它根据 $ 后面的函数名在函数表中查找，若查找到，则会根据函数信息进行函数调用，若没查找到，则会出错终止。

函数用 ret 命令向调用者返回值，有以下形式：

```c
ret         ; 返回空值 “/”
ret 1       ; 返回常数
ret a       ; 返回变量值
ret ~       ; 取出栈顶元素，返回其值。
```

函数返回时，会将调用者入栈的参数出栈，并在清栈后将返回值压入栈顶。